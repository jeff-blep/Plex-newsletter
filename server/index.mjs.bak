/* server/index.mjs */
import express from "express";
import cors from "cors";
import fs from "fs";
import path from "path";
import nodemailer from "nodemailer";
import { fileURLToPath } from "url";

/* ---------------------- helper: dynamic router loader ---------------------- */
async function loadRouter(modUrl, name) {
  try {
    const mod = await import(modUrl);
    const candidates = [
      mod.default,
      mod.router,
      mod.routes,
      mod[name],
      typeof mod.createRouter === "function" ? mod.createRouter() : undefined,
    ];
    const router = candidates.find(
      (r) => r && typeof r === "function" && typeof r.use === "function" && typeof r.get === "function"
    );
    if (!router) {
      console.error(`[router] ${name}: no usable router export found`, {
        hasDefault: !!mod.default,
        hasRouter: !!mod.router,
        hasRoutes: !!mod.routes,
        hasNamed: !!mod[name],
        hasCreateRouter: typeof mod.createRouter === "function",
        keys: Object.keys(mod || {}),
      });
    } else {
      console.log(`[router] ${name}: loaded OK`);
    }
    return router;
  } catch (e) {
    console.error(`[router] ${name}: failed to import`, e?.message || e);
    return undefined;
  }
}

/* ---------------------------- ESM dirname utils --------------------------- */
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/* ------------------------------- config I/O -------------------------------- */
const CONFIG_PATH = path.join(__dirname, "config.json");
const DEFAULT_CONFIG = {
  smtpHost: "",
  smtpPort: 587,
  smtpSecure: false,
  smtpUser: "",
  smtpPass: "",
  fromAddress: "",
  plexUrl: "",
  plexToken: "",
  tautulliUrl: "",
  tautulliApiKey: "",
  lookbackDays: 7,
  ownerRecommendation: {},
  lastTest: { plex: "unknown", tautulli: "unknown", smtp: "unknown" },
};

function loadConfig() {
  try {
    const raw = fs.readFileSync(CONFIG_PATH, "utf8");
    const parsed = JSON.parse(raw);
    return {
      ...DEFAULT_CONFIG,
      ...parsed,
      lastTest: { ...DEFAULT_CONFIG.lastTest, ...(parsed.lastTest || {}) },
      lookbackDays: typeof parsed.lookbackDays === "number" ? parsed.lookbackDays : 7,
      ownerRecommendation: parsed.ownerRecommendation || {},
    };
  } catch {
    return { ...DEFAULT_CONFIG };
  }
}
function saveConfig(cfg) {
  fs.writeFileSync(CONFIG_PATH, JSON.stringify(cfg, null, 2), "utf8");
}
let CONFIG = loadConfig();

/* --------------------------- recipients persistence ------------------------ */
const RECIPIENTS_PATH = path.join(__dirname, "recipients.json");
function isEmail(s) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(String(s || "").trim());
}
function loadRecipientsSafe() {
  try {
    if (!fs.existsSync(RECIPIENTS_PATH)) {
      fs.writeFileSync(RECIPIENTS_PATH, "[]", "utf8");
    }
    const txt = fs.readFileSync(RECIPIENTS_PATH, "utf8");
    const arr = JSON.parse(txt);
    return Array.isArray(arr) ? arr : [];
  } catch (e) {
    console.error("[recipients] load failed:", e?.message || e);
    return [];
  }
}
function saveRecipientsSafe(list) {
  try {
    fs.writeFileSync(RECIPIENTS_PATH, JSON.stringify(list, null, 2), "utf8");
    console.log("[recipients] wrote", RECIPIENTS_PATH, `(${list.length} items)`);
    return true;
  } catch (e) {
    console.error("[recipients] write failed:", e?.message || e);
    return false;
  }
}

/* ---------------------------- templates persistence ------------------------ */
const TEMPLATES_PATH = path.join(__dirname, "emailtemplates.json");

function loadTemplatesSafe() {
  try {
    if (!fs.existsSync(TEMPLATES_PATH)) {
      fs.writeFileSync(TEMPLATES_PATH, "[]", "utf8");
    }
    const txt = fs.readFileSync(TEMPLATES_PATH, "utf8");
    const arr = JSON.parse(txt);
    return Array.isArray(arr) ? arr : [];
  } catch (e) {
    console.error("[templates] load failed:", e?.message || e);
    return [];
  }
}
function saveTemplatesSafe(list) {
  try {
    fs.writeFileSync(TEMPLATES_PATH, JSON.stringify(list, null, 2), "utf8");
    console.log("[templates] wrote", TEMPLATES_PATH, `(${list.length} items)`);
    return true;
  } catch (e) {
    console.error("[templates] write failed:", e?.message || e);
    return false;
  }
}
function newId() {
  return Math.random().toString(36).slice(2) + Math.random().toString(36).slice(2);
}

/* -------------------------------- helpers --------------------------------- */
function applyIncomingSmtp(body, cfg) {
  if (typeof body.smtpHost === "string") cfg.smtpHost = body.smtpHost;
  if (typeof body.smtpPort === "number") cfg.smtpPort = body.smtpPort;
  if (typeof body.smtpSecure === "boolean") cfg.smtpSecure = body.smtpSecure;
  if (typeof body.smtpUser === "string") cfg.smtpUser = body.smtpUser;
  if (typeof body.smtpPass === "string" && body.smtpPass.length > 0) cfg.smtpPass = body.smtpPass;
  if (typeof body.fromAddress === "string") cfg.fromAddress = body.fromAddress;

  if (typeof body.smtpServer === "string") cfg.smtpHost = body.smtpServer;
  if (typeof body.smtpEmailLogin === "string") cfg.smtpUser = body.smtpEmailLogin;
  if (typeof body.smtpEmailPassword === "string" && body.smtpEmailPassword.length > 0)
    cfg.smtpPass = body.smtpEmailPassword;
  if (typeof body.smtpEncryption === "string")
    cfg.smtpSecure = body.smtpEncryption.toUpperCase() === "TLS/SSL";
}
function smtpTransportOptions(cfg) {
  const secure = !!cfg.smtpSecure;
  return {
    host: cfg.smtpHost,
    port: Number(cfg.smtpPort) || (secure ? 465 : 587),
    secure,
    requireTLS: !secure && Number(cfg.smtpPort) === 587,
    ignoreTLS: !secure && Number(cfg.smtpPort) === 25,
    auth: cfg.smtpUser ? { user: cfg.smtpUser, pass: cfg.smtpPass } : undefined,
  };
}

/* --------------------------------- app ------------------------------------ */
const app = express();
app.use(cors({ origin: "*" }));
app.use(express.json());
app.get("/__whoami", (_req, res) =>
  res.json({ file: __filename, configPath: CONFIG_PATH, recipientsPath: RECIPIENTS_PATH, templatesPath: TEMPLATES_PATH })
);

/* --------------------------- mount feature routers ------------------------- */
const plexRouter = await loadRouter(new URL("./routes/plex.mjs", import.meta.url), "plex");
const tautulliRouter = await loadRouter(new URL("./routes/tautulli.mjs", import.meta.url), "tautulli");

if (plexRouter) app.use("/api/plex", plexRouter);
if (tautulliRouter) app.use("/api/tautulli", tautulliRouter);

/* -------------------------- tiny debug observability ----------------------- */
app.get("/api/_routes", (_req, res) => {
  const stack = (app._router && app._router.stack) || [];
  const routes = [];
  for (const layer of stack) {
    if (layer.route && layer.route.path) {
      const methods = Object.keys(layer.route.methods || {}).filter(Boolean);
      routes.push({ path: layer.route.path, methods });
    } else if (layer.name === "router" && layer.regexp) {
      routes.push({ mounted: true, path: String(layer.regexp) });
    }
  }
  res.json({ routes });
});

// simple placeholder so the UI stops 404'ing until schedule is implemented
app.get("/api/schedule", (_req, res) => {
  res.json({ jobs: [] });
});

/* --------------------- recipients API (persistent file) -------------------- */
app.get("/api/recipients", (_req, res) => {
  res.json(loadRecipientsSafe());
});
app.post("/api/recipients", (req, res) => {
  const payload = Array.isArray(req.body) ? req.body : [];
  const cleaned = payload
    .map((r) => ({
      fullName: String(r?.fullName || r?.name || "").trim(),
      email: String(r?.email || "").trim().toLowerCase(),
    }))
    .filter((r) => isEmail(r.email))
    .reduce((acc, r) => (acc.find((x) => x.email === r.email) ? acc : acc.concat(r)), []);
  if (!saveRecipientsSafe(cleaned)) {
    return res.status(500).json({ ok: false, error: "Failed to write recipients.json" });
  }
  res.json({ ok: true, recipients: cleaned });
});

/* ---------------------- templates API (persistent file) -------------------- */
// GET all templates
app.get("/api/templates", (_req, res) => {
  res.json(loadTemplatesSafe());
});
// POST create/update by name (idempotent on name)
app.post("/api/templates", (req, res) => {
  const name = String(req.body?.name || "").trim();
  const html = String(req.body?.html ?? "");

  // NEW: optional historyDays (clamped 1..90)
  let historyDays = req.body?.historyDays;
  if (typeof historyDays !== "number" || Number.isNaN(historyDays)) {
    historyDays = undefined;
  } else {
    historyDays = Math.max(1, Math.min(90, Math.floor(historyDays)));
  }

  if (!name) return res.status(400).json({ ok: false, error: "Missing template name" });

  const list = loadTemplatesSafe();
  const now = Date.now();

  // If name exists, update; else add new
  const existing = list.find((t) => t.name.toLowerCase() === name.toLowerCase());
  if (existing) {
    existing.html = html;
    if (historyDays !== undefined) existing.historyDays = historyDays; // persist if provided
    existing.updatedAt = now;
  } else {
    const item = { id: newId(), name, html, updatedAt: now };
    if (historyDays !== undefined) item.historyDays = historyDays;
    list.push(item);
  }

  if (!saveTemplatesSafe(list)) {
    return res.status(500).json({ ok: false, error: "Failed to write emailtemplates.json" });
  }
  res.json({ ok: true, templates: list });
});
// DELETE by id
app.delete("/api/templates/:id", (req, res) => {
  const id = String(req.params.id || "");
  if (!id) return res.status(400).json({ ok: false, error: "Missing id" });
  const list = loadTemplatesSafe();
  const next = list.filter((t) => t.id !== id);
  if (!saveTemplatesSafe(next)) {
    return res.status(500).json({ ok: false, error: "Failed to write emailtemplates.json" });
  }
  res.json({ ok: true, templates: next });
});

/* -------------------------------- API routes ------------------------------ */
app.get("/api/config", (_req, res) => {
  const { smtpPass, ...rest } = CONFIG;
  res.json(rest);
});
app.post("/api/config", (req, res) => {
  const b = req.body || {};
  if (typeof b.plexUrl === "string") CONFIG.plexUrl = b.plexUrl;
  if (typeof b.plexToken === "string") CONFIG.plexToken = b.plexToken;
  if (typeof b.tautulliUrl === "string") CONFIG.tautulliUrl = b.tautulliUrl;
  if (typeof b.tautulliApiKey === "string") CONFIG.tautulliApiKey = b.tautulliApiKey;
  if (typeof b.lookbackDays === "number") CONFIG.lookbackDays = b.lookbackDays;
  if (b.ownerRecommendation && typeof b.ownerRecommendation === "object") {
    CONFIG.ownerRecommendation = b.ownerRecommendation;
  }
  applyIncomingSmtp(b, CONFIG);
  saveConfig(CONFIG);
  res.json({ ok: true });
});
app.get("/api/status", (_req, res) => {
  const s = CONFIG.lastTest || {};
  res.json({ emailOk: s.smtp === "ok", plexOk: s.plex === "ok", tautulliOk: s.tautulli === "ok" });
});
app.post("/api/test/plex", async (req, res) => {
  const plexUrl = (req.body && req.body.plexUrl) || CONFIG.plexUrl;
  const plexToken = (req.body && req.body.plexToken) || CONFIG.plexToken;
  try {
    if (!plexUrl || !plexToken) throw new Error("Missing plexUrl or plexToken");
    const urlWithScheme = /^https?:\/\//i.test(plexUrl) ? plexUrl : `http://${plexUrl}`;
    const sep = urlWithScheme.includes("?") ? "&" : "?";
    const probe = `${urlWithScheme}${sep}X-Plex-Token=${encodeURIComponent(plexToken)}`;
    const ac = new AbortController();
    const timer = setTimeout(() => ac.abort(), 5000);
    let r;
    try {
      r = await fetch(probe, { method: "GET", signal: ac.signal });
    } finally {
      clearTimeout(timer);
    }
    if (!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
    CONFIG.lastTest.plex = "ok";
    saveConfig(CONFIG);
    res.json({ ok: true });
  } catch (e) {
    CONFIG.lastTest.plex = "fail";
    saveConfig(CONFIG);
    res.json({ ok: false, error: e?.message || String(e) });
  }
});
app.post("/api/test-plex", (req, res) =>
  app._router.handle({ ...req, url: "/api/test/plex", method: "POST" }, res, () => {})
);
app.post("/api/test/tautulli", async (req, res) => {
  const tUrlRaw = (req.body && req.body.tautulliUrl) || CONFIG.tautulliUrl;
  const apiKey = (req.body && req.body.tautulliApiKey) || CONFIG.tautulliApiKey;
  try {
    if (!tUrlRaw || !apiKey) throw new Error("Missing tautulliUrl or tautulliApiKey");
    const tUrl = /^https?:\/\//i.test(tUrlRaw) ? tUrlRaw : `http://${tUrlRaw}`;
    const base = `${tUrl}`.replace(/\/+$/, "");
    const probe = `${base}/api/v2?apikey=${encodeURIComponent(apiKey)}&cmd=get_activity`;
    const ac = new AbortController();
    const timer = setTimeout(() => ac.abort(), 5000);
    let r;
    try {
      r = await fetch(probe, { method: "GET", signal: ac.signal });
    } finally {
      clearTimeout(timer);
    }
    if (!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
    const json = await r.json().catch(() => null);
    const ok = json && json.response && json.response.result === "success";
    if (!ok) throw new Error("Unexpected response from Tautulli");
    CONFIG.lastTest.tautulli = "ok";
    saveConfig(CONFIG);
    res.json({ ok: true });
  } catch (e) {
    CONFIG.lastTest.tautulli = "fail";
    saveConfig(CONFIG);
    res.json({ ok: false, error: e?.message || String(e) });
  }
});
app.post("/api/test-tautulli", (req, res) =>
  app._router.handle({ ...req, url: "/api/test/tautulli", method: "POST" }, res, () => {})
);
app.post("/api/test-email", async (req, res) => {
  const merged = { ...CONFIG };
  if (req.body && typeof req.body === "object") {
    merged.smtpHost = req.body.smtpHost ?? merged.smtpHost;
    merged.smtpPort = typeof req.body.smtpPort === "number" ? req.body.smtpPort : merged.smtpPort;
    merged.smtpSecure = typeof req.body.smtpSecure === "boolean" ? req.body.smtpSecure : merged.smtpSecure;
    merged.smtpUser = req.body.smtpUser ?? merged.smtpUser;
    merged.smtpPass = req.body.smtpPass && req.body.smtpPass.length > 0 ? req.body.smtpPass : merged.smtpPass;
    merged.fromAddress = req.body.fromAddress ?? merged.fromAddress ?? merged.smtpUser;
  }
  try {
    if (!merged.smtpHost || !merged.smtpPort) throw new Error("Missing SMTP server/port");
    if (!merged.fromAddress) throw new Error("Missing From Address");
    const transport = nodemailer.createTransport(smtpTransportOptions(merged));
    await transport.verify();
    if (req.body && typeof req.body.to === "string" && req.body.to.length > 0) {
      await transport.sendMail({
        from: merged.fromAddress,
        to: req.body.to,
        subject: "Kunkflix Newsletter SMTP Test",
        text: "This is a test email confirming your SMTP settings are working.",
      });
    }
    applyIncomingSmtp(req.body || {}, CONFIG);
    CONFIG.lastTest.smtp = "ok";
    saveConfig(CONFIG);
    res.json({ ok: true });
  } catch (e) {
    CONFIG.lastTest.smtp = "fail";
    saveConfig(CONFIG);
    res.json({ ok: false, error: e?.message || String(e) });
  }
});
app.post("/api/test/smtp", (req, res) =>
  app._router.handle({ ...req, url: "/api/test-email", method: "POST" }, res, () => {})
);
/* --------- Plex identity helpers (for official app.plex.tv links) --------- */
let CACHED_PLEX_SERVER_ID = null;

function trimRightSlash(u = "") {
  return String(u || "").replace(/\/+$/, "");
}

async function fetchPlexIdentity() {
  const base = trimRightSlash(CONFIG.plexUrl);
  const token = CONFIG.plexToken || "";
  if (!base || !token) throw new Error("Missing Plex URL or token in config.json");

  const url = `${base}/identity?X-Plex-Token=${encodeURIComponent(token)}`;
  const ac = new AbortController();
  const timer = setTimeout(() => ac.abort(), 5000);
  try {
    const r = await fetch(url, { signal: ac.signal });
    const txt = await r.text();
    if (!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}: ${txt}`);

    // Extract machineIdentifier (the server ID) from the XML response
    const idMatch = txt.match(/machineIdentifier="([^"]+)"/i);
    const nameMatch = txt.match(/friendlyName="([^"]+)"/i);
    const machineIdentifier = idMatch ? idMatch[1] : null;
    const friendlyName = nameMatch ? nameMatch[1] : null;
    return { machineIdentifier, friendlyName, raw: txt };
  } finally {
    clearTimeout(timer);
  }
}

/* GET /api/plex/identity  -> { machineIdentifier, friendlyName } */
app.get("/api/plex/identity", async (_req, res) => {
  try {
    const { machineIdentifier, friendlyName } = await fetchPlexIdentity();
    if (!machineIdentifier) return res.status(500).json({ error: "Unable to parse machineIdentifier" });
    // cache for the life of the process
    CACHED_PLEX_SERVER_ID = machineIdentifier;
    res.json({ machineIdentifier, friendlyName });
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});

/* GET /api/plex/server-id  -> { machineIdentifier } (small convenience wrapper) */
app.get("/api/plex/server-id", async (_req, res) => {
  try {
    if (CACHED_PLEX_SERVER_ID) return res.json({ machineIdentifier: CACHED_PLEX_SERVER_ID });
    const { machineIdentifier } = await fetchPlexIdentity();
    if (!machineIdentifier) return res.status(500).json({ error: "Unable to parse machineIdentifier" });
    CACHED_PLEX_SERVER_ID = machineIdentifier;
    res.json({ machineIdentifier });
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});

// --- minimal helpers (local to this file) ---
function trimSlash(u = "") { return String(u || "").replace(/\/+$/, ""); }
async function fetchWithTimeout(url, ms = 6000) {
  const ac = new AbortController();
  const t = setTimeout(() => ac.abort(), ms);
  try { return await fetch(url, { signal: ac.signal }); }
  finally { clearTimeout(t); }
}

// --- NEW: expose Plex identity + server-id directly ---
app.get("/api/plex/identity", async (_req, res) => {
  try {
    const base = trimSlash(CONFIG.plexUrl || "");
    const token = CONFIG.plexToken || "";
    if (!base || !token) return res.status(400).json({ error: "Missing Plex config" });

    const r = await fetchWithTimeout(`${base}/identity?X-Plex-Token=${encodeURIComponent(token)}`, 6000);
    const text = await r.text();
    if (!r.ok) return res.status(r.status).send(text);

    const machineIdentifier = text.match(/machineIdentifier="([^"]+)"/i)?.[1] || null;
    const friendlyName = text.match(/friendlyName="([^"]+)"/i)?.[1] || null;
    if (!machineIdentifier) return res.status(500).json({ error: "Unable to parse machineIdentifier" });

    res.json({ machineIdentifier, friendlyName });
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});

app.get("/api/plex/server-id", async (_req, res) => {
  try {
    const base = trimSlash(CONFIG.plexUrl || "");
    const token = CONFIG.plexToken || "";
    if (!base || !token) return res.status(400).json({ error: "Missing Plex config" });

    const r = await fetchWithTimeout(`${base}/identity?X-Plex-Token=${encodeURIComponent(token)}`, 6000);
    const text = await r.text();
    if (!r.ok) return res.status(r.status).send(text);

    const machineIdentifier = text.match(/machineIdentifier="([^"]+)"/i)?.[1] || null;
    if (!machineIdentifier) return res.status(500).json({ error: "Unable to parse machineIdentifier" });

    res.json({ machineIdentifier });
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});
// ---- DIAG 1: list routes on startup (once)
setTimeout(() => {
  const stack = (app._router && app._router.stack) || [];
  const routes = [];
  for (const layer of stack) {
    if (layer.route && layer.route.path) {
      const methods = Object.keys(layer.route.methods || {}).filter(Boolean);
      routes.push({ path: layer.route.path, methods });
    }
  }
  console.log("[diag] routes now registered:", routes);
}, 100);

// ---- DIAG 2: log any /api/newsletters misses (404s reaching here)
app.use((req, _res, next) => {
  if (req.path.startsWith("/api/newsletters")) {
    console.log("[diag] hit newsletters path:", req.method, req.path, "— handler may be missing above");
  }
  next();
});
/* --------------------------------- start ---------------------------------- */
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`API listening on http://localhost:${PORT}`);
  console.log(`config.json -> ${CONFIG_PATH}`);
  console.log(`recipients.json -> ${RECIPIENTS_PATH}`);
  console.log(`emailtemplates.json -> ${TEMPLATES_PATH}`);
});
